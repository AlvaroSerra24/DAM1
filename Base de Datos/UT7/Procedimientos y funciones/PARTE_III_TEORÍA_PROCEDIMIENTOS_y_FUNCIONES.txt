SET SERVEROUTPUT ON
SET VERIFY OFF
/* Estructura:

PROCEDURE <nombreprocedimiento> [( <lista de par?metros> )]
IS
	<declaraciones>;	-- equivalente a la sección declare
BEGIN
	<instrucciones>;
EXCEPTION
	<excepciones>;
END [<nombreprocedimiento>];


Donde los parámetros tienen la siguiente sintaxis:
<nombrevariable> [ IN | OUT | IN OUT ] < tipodedato> [ { := | DEFAULT } <valor>]
?	Al indicar los parámetros debemos especificar el tipo, pero no el tama?o.
?	En el caso de que no tenga par?metros no se pondr?n los par?ntesis.
?	Las declaraciones se hacen despu?s del IS que equivale al DECLARE, 
    en este caso si se deber? indicar la longitud de las variables locales.
En la estructura general de un procedimiento se pueden apreciar dos partes:
?	La especificaci?n (cabecera) del procedimiento: Comienza con la palabra PROCEDURE
    y termina despu?s del ?ltimo par?metro.
?	El cuerpo del procedimiento: Comienza con la palabra IS y termina con la palabra END
opcionalmente seguida del nombre del procedimiento.
  
*/

/* Ejemplo 1: PROCEDIMIENTO PARA IMPRIMIR EL DEPARTAMENTO CON MÁS EMPLEADOS */

DECLARE 
    REGISTRO DEPART%ROWTYPE;
    PROCEDURE VER(REG DEPART%ROWTYPE) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('NUM: '||REG.DEPT_NO);
        DBMS_OUTPUT.PUT_LINE('DNOMBRE: '||REG.DNOMBRE);
        DBMS_OUTPUT.PUT_LINE('LOC: '||REG.LOC);
    END VER;

BEGIN
   SELECT * INTO REGISTRO FROM DEPART
   WHERE DEPT_NO IN(SELECT DEPT_NO FROM EMPLE
                    GROUP BY DEPT_NO
                    HAVING COUNT(*)= (SELECT MAX(COUNT(*)) FROM EMPLE 
                                    GROUP BY DEPT_NO));
    
    VER(REGISTRO);
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE('HAY MÁS DE UN DEPARTAMENTO CON EL MAXIMO');
            
END;


/* PROCEDURES ALMACENADOS (SE ALMACEN EN LA BD COMO SI
FUERA OTRO OBJETO) . HAY QUE CREAR EL CÓDIGO EN LA HOJA DE .SQL Y COMPILARLO. 
*/

CREATE OR REPLACE 
  PROCEDURE VERDEPARTAMENTO(NUM NUMBER) IS
  REG DEPART%ROWTYPE;
  
  BEGIN
    
    SELECT * INTO REG FROM DEPART WHERE DEPT_NO=NUM;
    DBMS_OUTPUT.PUT_LINE('****NUM DEPART: '||REG.DEPT_NO||
                                 '  NOMBRE DEPART: '||REG.DNOMBRE||
                                 '  LOCALIDAD: '||REG.LOC);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE EL DPTO');
  END VERDEPARTAMENTO;

/* EJEMPLO: LISTAR TODOS LOS DEPARTAMENTOS, USANDO EL 
   PROCEDURE VERDEPARTAMENTO */
   
DECLARE 
    CURSOR C1 IS SELECT DEPT_NO FROM DEPART;
    REG DEPART.DEPT_NO%TYPE;
BEGIN
    OPEN C1;
    LOOP
        FETCH C1 INTO REG;
        EXIT WHEN C1%NOTFOUND;
        VERDEPARTAMENTO(reg);
    END LOOP;
    CLOSE C1;
END;

/* CONVERTIR EL BLOQUE DE PL ANTERIOR EN UN PROCEDIMIENTO ALMACENADO */

CREATE OR REPLACE PROCEDURE LISTAR_DEPARTAMENTOS IS
    CURSOR C1 IS SELECT DEPT_NO FROM DEPART;
    REG DEPART.DEPT_NO%TYPE;
BEGIN
    OPEN C1;
    LOOP
        FETCH C1 INTO REG;
        EXIT WHEN C1%NOTFOUND;
        VERDEPARTAMENTO(reg);
    END LOOP;
    CLOSE C1;
END LISTAR_DEPARTAMENTOS;

-- DOS FORMAS PARA EJECUTARLO:
-- OPCIÓN 1: CREAR UN BLOQUE DE PL Y REALIZAR UNA LLAMADA AL PROCEDIMIENTO. 
BEGIN
    LISTAR_DEPARTAMENTOS;
END;

-- OPCIÓN 2: USAR EXEC. 
EXEC LISTAR_DEPARTAMENTOS;



/* EJEMPLO 4: CONVERTIR EL PROCEDIMIENTO VEREMPLEADO 
EN UN PROCEDIMIENTO ALMACENADO Y CAMBIAR LA LLAMADA AL 
PROCEDIMIENTO */
CREATE OR REPLACE PROCEDURE LISTA_EMPLEADO(N_EMP NUMBER) IS
    REGEMP EMPLE%ROWTYPE;
BEGIN
    SELECT * INTO REGEMP FROM EMPLE 
    WHERE EMP_NO=N_EMP;
    
    DBMS_OUTPUT.PUT_LINE('CODIGO: '||REGEMP.EMP_NO||
                         ' APELLIDOS: '||REGEMP.APELLIDO||
                         ' OFICIO: '||REGEMP.OFICIO);
    
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('EMPLEADO NO EXISTE');
    
END LISTA_EMPLEADO;

/* DADO UN DEPARTAMENTO, LISTAR LOS DATOS DE SUS EMPLEADOS */
CREATE OR REPLACE PROCEDURE LISTAR_EMP_DPTO(N_DPTO NUMBER) IS
    CURSOR C1(NUME NUMBER) IS 
       SELECT * FROM EMPLE WHERE DEPT_NO=NUME;
    REGEMP C1%ROWTYPE;
BEGIN
    FOR REGEMP IN C1(N_DPTO) LOOP
        LISTA_EMPLEADO(REGEMP.DEPT_NO);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('LA MEDIA DE SALARIOS ES: '||TO_cHAR(MEDIA(N_DPTO),'9G999G999D99L'));
    -- OJO!! LA FUNCION MEDIA LA HEMOS AÑADIDO DESPUÉS. 
END LISTAR_EMP_DPTO;

--PARA PROBAR:
EXEC LISTAR_EMP_DPTO(10);


/* COMPLEMENTAR EL PROCEDURE ANTERIOR PARA CONTROLAR:+
   - DPTO NO EXISTE. 
   - DPTO NO TIENE EMPLEADOS */
   
   
/* FUNCIONES: LA DIFERENCIA ENTRE PROCEDIMIENTOS Y FUNCIONES ES QUE ESTAS ÚLTIMAS, DEVUELVEN 
UN VALOR. ES OBLIGATORIO DECLARA EL TIPO DEVUELTO EN LA CABECERA DE LA FUNCIÓN Y NO OLVIDAR HACER
EL RETURN EN EL CUERPO DE LA FUNCIÓN.  */
/* LA SINTAXIS DE LA FUNCIÓN ES LA SIGUIENTE: 

CREATE OR REPLACE 
     FUNCTION nombre_función (parámetros) 
	   RETURN <tipo de valor devuelto >
IS
	 -- <declaraciones>;
BEGIN
	-- <instrucciones>;
	RETURN <valor>;
	...
EXCEPTION
	<excepciones>;
END <nombredefuncion>;

*/

/* EJEMPLO: CREAR UNA FUNCIÓN QUE ME DEVUELVA LA MEDIA DEL SALARIO DE UN DPTO */

/* LAS FUNCIONES TAMBIÉN HAY QUE COMPILARLAS Y UNA VEZ CREADAS EN MEMORIA PUEDEN SER USADAS 
POR OTROS OBJETOS DE LA BASE DE DATOS O EN HOJAS DE .SQL EN BLOQUES */

CREATE OR REPLACE FUNCTION MEDIA (DEP NUMBER)  RETURN NUMBER IS 
   MEDIA NUMBER(9,2);
BEGIN 
   SELECT AVG(SALARIO) INTO MEDIA 
        FROM EMPLE WHERE DEPT_NO=DEP;
   RETURN MEDIA;
END MEDIA;

