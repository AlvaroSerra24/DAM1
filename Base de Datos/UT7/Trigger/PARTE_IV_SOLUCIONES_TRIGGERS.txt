
/*  En estos ejercicios, vamos a usar la función 
RAISE_APPLICATION_ERROR se utiliza para comunicar de forma interactiva,
una excepción predefinida, devolviendo un código y 
un mensaje de error no estándar. Se usa por tanto en la zona de exception o 
en el cuerpo del programa. 

RAISE_APPLICATION_ERROR (error_number, message[, {TRUE | FALSE}]);
En la sintaxis:
error_number:es un número de excepción especificado por el usuario; 
             rango entre –20,000 y –20,999.
message: es el mensaje de excepción especificado por el usuario; 
         con longitud máxima de 2,048 bytes.
TRUE | FALSE: es un parámetro booleano opcional 
(Si es TRUE, el error se coloca en la pila de errores anteriores.
Si es FALSE(por defecto), el error sustituye a todos los errores 
anteriores.) */


/* 1.	Crea un disparador que se ejecute al insertar en DEPART,
debe comprobar que el DEPT_NO sea mayor de 0, si no es 
así hay que hacer que no se inserte el registro en la tabla. */
CREATE OR REPLACE TRIGGER COMPRUEBA_DPTO 
        BEFORE INSERT ON DEPART FOR EACH ROW
BEGIN
    IF :NEW.DEPT_NO <0 THEN
        RAISE_APPLICATION_ERROR(-20000,'EL DPTO ES MENOR QUE CERO');
    END IF;

END;

--PRUEBAS
INSERT INTO DEPART VALUES(1, 'DPTO 1','TALAVERA');
INSERT INTO DEPART VALUES(-2, 'DPTO -2','TALAVERA');


/* 2.	Crear un trigger que se ejecute cuando se inserte en emple, 
hay que comprobar que el oficio sea uno de los que aparece en 
la tabla
EMPLE.
Abortar el trigger si no es un oficio de los que hay en la tabla  */
CREATE OR REPLACE TRIGGER COMPRUEBA_OFICIO 
        BEFORE INSERT ON EMPLE FOR EACH ROW
DECLARE
    CONT NUMBER(2);
BEGIN
    SELECT COUNT(*) INTO CONT FROM EMPLE WHERE OFICIO=:NEW.OFICIO;
    IF CONT=0 THEN 
        raise_application_error(-20000,'Oficio no Existe');
    END IF;
END;

INSERT INTO EMPLE VALUES (5,'AMOR 5','ASESOR',1,SYSDATE,100,100,10);


-- CON NO_DATA_FOUND
CREATE OR REPLACE TRIGGER COMPRUEBA_OFICIO_2 
        BEFORE INSERT ON EMPLE FOR EACH ROW
DECLARE
    REG EMPLE%ROWTYPE;
BEGIN
    SELECT * INTO REG FROM EMPLE WHERE OFICIO=:NEW.OFICIO;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        raise_aplication_error(-20000,'Oficio no Existe');
    END IF;
END;

INSERT INTO EMPLE VALUES (5,'AMOR 5','ASESOR',1,SYSDATE,100,100,10);

/* 3.	Crear un trigger que se ejecute cuando se borre un empleado 
con el oficio ‘PRESIDENTE’. En ese caso hacer que no se ejecute el 
borrado. */
CREATE OR REPLACE TRIGGER NO_BORRES_PRESIDENTE 
     BEFORE DELETE ON EMPLE FOR EACH ROW
BEGIN
    IF :OLD.OFICIO LIKE 'PRESIDENTE' THEN
        raise_apPlication_error(-20000,'nO SE PUEDE BORRAR EL PTE');
    END IF;
END;

DELETE FROM EMPLE WHERE EMP_NO=7839;

/* 4. Escribir un disparador que haga fallar cualquier operación de
modificación del apellido o del número de un empleado, o que suponga 
una subida de sueldo superior al 10% en la tabla EMPLE */
create or replace trigger impide_modifica_datos 
            before update of apellido, emp_no, salario on emple for each row
begin
    if updating('emp_no') then
        raise_application_error(-20000,'No se puede cambiar el num empleado');
    end if;
    
    if updating ('apellido') then 
        raise_application_error(-20000,'No se puede cambiar el apellido');
    end if;
    
    if :new.salario-:old.salario>:new.salario*0.1 then
        raise_application_error(-20002,'El salario no puede subirse más de un 10%');
    end if;
end;
 
-- pruebas
update emple set emp_no=8 where emp_no=7839;

update emple set apellido='cambio' where emp_no=7839;
update emple set SALARIO=SALARIO*2 WHERE EMP_NO=7839;

/* 5.	Añadir una columna a la tabla depart, con nombre num_emple. 
Esta columna debe almacenar el número de empleados de la tabla emple de
ese departamento. Se trata de mantener actualizado el número de empleados 
de la tabla emple que son del departamento. El trigger se va a disparar 
cuando insertemos, borremos o modifiquemos en la tabla emple. */
alter table depart add (num_emple number(2) default 0);

-- implementamos el trigger (A nivel de sentencia)
create or replace trigger actu_num_emple
after insert or update or delete on emple

begin
  update depart d set num_emple=
      (select count(*) from emple 
            where dept_no= d.dept_no);
end;

DELETE FROM EMPLE WHERE EMP_NO=1;


--Crearlo a nivel de fila (RESUELTO ANTES A NIVEL DE SENTENCIA).

create or replace trigger actudeparemples  
     after insert or delete or update of dept_no  on emple for each row
begin
  if inserting then
      update depart set num_emple = num_emple + 1  where dept_no = :new.dept_no;
  end if;
  if deleting then
       update depart set num_emple = num_emple – 1  where dept_no = :old.dept_no;
  end if;
  
  if updating then
       update depart set num_emple = num_emple + 1
         where dept_no = :new.dept_no;
       update depart set num_emple = num_emple - 1
         where dept_no = :old.dept_no;
  end if;
  end;

--pruebas
insert into emple values  ( 1178, 'Ape 1178', 'VENDEDOR',1, sysdate, 1000,0,10);
update emple set dept_no = 40 where emp_no = 1178;
delete emple where emp_no = 1178;

/* 6.	Escribe un trigger que permita auditar de la tabla EMPLE, 
las operaciones de inserción y borrado. 
Para ello se creará la tabla AUDITAEMPLE con una columna de 200 caracteres.
Cuando se produzca el evento insertar la fecha, la hora, el número de empleado, 
el apellido y la operación realizada, INSERCIÓN o BORRADO.	*/
CREATE  TABLE AUDITAEMPLE ( MENSAJE VARCHAR2(200));

CREATE OR REPLACE TRIGGER EMPE_INS_DEL   AFTER INSERT OR DELETE ON EMPLE
    FOR EACH ROW

DECLARE
HORA VARCHAR2(8);
BEGIN
IF INSERTING THEN
    HORA:= TO_CHAR(SYSDATE,'HH:MM:SS');
   INSERT INTO AUDITAEMPLE VALUES ('FECHA: '||SYSDATE||', HORA '||
     HORA || ', NUM EMPLE: '|| :NEW.EMP_NO ||', APELLIDO: '||
     :NEW.APELLIDO ||', INSERCIÓN');  
END IF;
IF DELETING THEN
  HORA:= TO_CHAR(SYSDATE,'HH:MM:SS');
  INSERT INTO AUDITAEMPLE VALUES ('FECHA: '||SYSDATE||', HORA '||
     HORA || ', NUM EMPLE: '|| :OLD.EMP_NO ||', APELLIDO: '||
     :OLD.APELLIDO ||', BORRADO');  
END IF;
END;

INSERT INTO EMPLE VALUES   ( 1177, 'APE 1177', 'VENDEDOR',1, SYSDATE, 1000,0,30);
DELETE EMPLE WHERE EMP_NO=1177;
DELETE EMPLE WHERE DEPT_NO=30;
SELECT * FROM AUDITAEMPLE ;
INSERT INTO EMPLE  SELECT * FROM EMPLE;



/* 7.	Realizar un trigger para controlar las modificaciones en la 
tabla EMPLE. Si ocurre una modificación se grabará en audita_emple, 
la fecha y hora, el número de empleado, el apellido, la operación de 
MODIFICACIÓN, y además el valor anterior y nuevo de las columnas modificadas,
sólo de las columnas modificadas. */

CREATE OR REPLACE TRIGGER EMPLE_MODIF AFTER UPDATE ON EMPLE FOR EACH ROW
DECLARE
   MENSAJE VARCHAR2(400):= '';
BEGIN
MENSAJE :='FECHA:'||SYSDATE||', HORA:'||TO_CHAR(SYSDATE,'HH:MM:SS')||
'NUM EMPLE: '||:NEW.EMP_NO || ', APELLIDO: '||:NEW.APELLIDO||'. MODIFICACIÓN. ';

IF UPDATING('EMP_NO') THEN
  MENSAJE := MENSAJE ||'MOD EMP_NO, ANTIGUO: '||:OLD.EMP_NO ||'. ';
END IF;

IF UPDATING('APELLIDO') THEN
   MENSAJE := MENSAJE ||'MOD APE, ANTIGUO: '||:OLD.APELLIDO ||'. ';
END IF;

IF UPDATING('OFICIO') THEN
 MENSAJE := MENSAJE ||'OFICIO, ANT: '||:OLD.OFICIO || ', NUEV: '||:NEW.OFICIO ||'. ';
END IF;

IF UPDATING('DIR') THEN
MENSAJE := MENSAJE ||'DIR, ANT: '||:OLD.DIR || ', NUEV: '||:NEW.DIR ||'. ';
END IF;

IF UPDATING('FECHA_ALT') THEN
MENSAJE := MENSAJE ||'FEC, ANT: '||:OLD.FECHA_ALT || ', NUEV: '||:NEW.FECHA_ALT ||'. ';
END IF;

IF UPDATING('SALARIO') THEN
MENSAJE := MENSAJE ||'SALARIO, ANT: '||:OLD.SALARIO || ', NUEV: '||:NEW.SALARIO ||'. ';
END IF;
IF UPDATING('DEPT_NO') THEN
 MENSAJE := MENSAJE ||'DEP_NO, ANT: '||:OLD.DEPT_NO || ', NUEV: '||:NEW.DEPT_NO ||'. ';
END IF;
IF UPDATING('COMISION') THEN
MENSAJE := MENSAJE ||'COM, ANT: '||:OLD.COMISION || ', NUEV: '||:NEW.COMISION ||'. ';
END IF;

INSERT INTO AUDITAEMPLE VALUES (MENSAJE);

END;

UPDATE EMPLE SET SALARIO = SALARIO + 100, COMISION = 50 WHERE DEPT_NO = 20;

INSERT INTO EMPLE VALUES   ( 1178, 'APE 1178', 'VENDEDOR',1, SYSDATE, 1000,0,30);

UPDATE EMPLE SET  APELLIDO  = 'APENUE1179', OFICIO = 'OFINUE', DIR= 100, 
    FECHA_ALT = SYSDATE - 10, SALARIO   = 1500,  COMISION  = 300 ,  DEPT_NO   = 10, EMP_NO = 1179
WHERE EMP_NO = 1178;

ALTER TABLE AUDITAEMPLE  MODIFY (MENSAJE VARCHAR2(400 BYTE) );
SELECT * FROM AUDITAEMPLE;


/* 8.	Crear la columna NUM_ARTIS dentro de la tabla proveedores. Numérica
de 4 dígitos. Debe guardar el número de artículos que suministra el proveedor
Realizar un trigger para mantener actualizada esa columna. */

alter table proveedores add num_artis number(4) default 0;

/* TABLAS MUTANTES */
create or replace trigger actu_num_artis 
    after insert or delete or update on suministros  for each row
DECLARE
    CONT NUMBER(2):=0;
begin
   select count(*) INTO CONT from suministros where codprov=:OLD.codprov;
   update proveedores p set num_artis=CONT; 
end;

DELETE FROM SUMINISTROS WHERE CODPROV=1 AND CODARTI=13;

/* ERROR DE TABLAS MUTANTES: CUANDO SE ESTÁ EJECUTANDO UN TRIGGER EN UNA 
TABLA, SE DICE QUE LA TABLA QUE HIZO QUE SE DISPARARA ESTÁ EN "PROCESO
DE MUTACIÓN" POR LO QUE NO SE PUEDE REALIZAR NINGUNA OTRA OPERACIÓN SOBRE
LA MISMA TABLA. OPERACIÓN COMO DELETE, INSERT, UPDATE O SELECT */


/* para solucionarlo, USAR REFERENCIAS O CONSULTA CORRELACIONADA */


create or replace trigger actu_num_artis 
after insert or delete or update of codarti on suministros
begin
update proveedores p set num_artis = 
   (select count(*) 
    from suministros where codprov = p.codprov);
end;

insert into suministros values (1,5);
delete suministros where codprov = 1;
update suministros set codarti = 9 where codprov = 2  and codarti = 1;

/* TABLAS MUTANTES */
create or replace trigger actu_num_artis 
    after insert or delete or update on suministros 
DECLARE
    CONT NUMBER(2):=0;
begin
   select count(*) INTO CONT from suministros where codprov = OLD:codprov;
   update proveedores p set num_artis = CONT; 
end;

DELETE FROM SUMINISTROS WHERE CODPROV=1 AND CODARTI=13;

/* ERROR DE TABLAS MUTANTES: CUANDO SE ESTÁ EJECUTANDO UN TRIGGER EN UNA 
TABLA, SE DICE QUE LA TABLA QUE HIZO QUE SE DISPARARA ESTÁ EN "PROCESO
DE MUTACIÓN" POR LO QUE NO SE PUEDE REALIZAR NINGUNA OTRA OPERACIÓN SOBRE
LA MISMA TABLA. OPERACIÓN COMO DELETE, INSERT, UPDATE O SELECT */




/* 9.	Crear dentro de la tabla COMPRAS la columna IMPORTECOMPRA,
numérico 9,2. Esta columna debe almacenar el total de la compra,
que será la suma de unidades * precio de los artículos que forman
la compra.
Realizar un trigger para mantener actualizada esa columna.
A nivel de sentencia */

-- CREAR TABLA AUDITORIA
CREATE TABLE AUDITA_DET_COMPRAS (INFORMACION VARCHAR2(100));

-- AÑADIR EL CAmPO A LA TABLA COMPRAS
ALTER TABLE COMPRAS ADD (IMPORTECOMPRAS NUMBER(9,2) DEFAULT 0);

-- TRIGGER A NIVEL DE SENTENCIA
CREATE OR REPLACE TRIGGER ACTUALIZA_IMPORTE_COMPRAS 
      AFTER INSERT OR DELETE OR UPDATE ON DET_COMPRAS
BEGIN
    UPDATE COMPRAS C SET IMPORTECOMPRAS=
           (SELECT NVL(SUM(UNIDADES*PVP),0) 
             FROM DET_COMPRAS JOIN ARTICULOS
             USING(CODARTI)
             WHERE C.NUM_COMPRA=NUM_COMPRA);
    INSERT INTO AUDITA_DET_COMPRAS 
        VALUES (TO_CHAR(SYSDATE, 'HH:MM:SS') || 'NIVEL SENTENCIA');      

END;

-- PRUEBAS
INSERT INTO DET_COMPRAS VALUES (4,9,5);
INSERT INTO DET_COMPRAS VALUES (6,9,5);

-- TRIGGER A NIVEL DE FILA
CREATE OR REPLACE TRIGGER ACTUALIZA_IMPORTE_COMPRAS_FILA
      AFTER INSERT OR DELETE OR UPDATE ON DET_COMPRAS FOR EACH ROW 
DECLARE
    PRECIO NUMBER(9,2);
BEGIN
    IF INSERTING THEN
        SELECT PVP INTO PRECIO FROM ARTICULOS 
        WHERE CODARTI=:NEW.CODARTI;
        UPDATE COMPRAS SET 
              IMPORTECOMPRAS=IMPORTECOMPRAS+PRECIO*:NEW.UNIDADES
        WHERE NUM_COMPRA=:NEW.NUM_COMPRA;
    END IF;
    
    IF DELETING THEN
        SELECT PVP INTO PRECIO FROM ARTICULOS 
        WHERE CODARTI=:OLD.CODARTI;
        UPDATE COMPRAS SET 
              IMPORTECOMPRAS=IMPORTECOMPRAS-PRECIO*:OLD.UNIDADES
        WHERE NUM_COMPRA=:OLD.NUM_COMPRA;
    END IF;
    
    IF UPDATING THEN
        SELECT PVP INTO PRECIO FROM ARTICULOS 
        WHERE CODARTI=:NEW.CODARTI;
        UPDATE COMPRAS SET 
              IMPORTECOMPRAS=IMPORTECOMPRAS+PRECIO*:NEW.UNIDADES
        WHERE NUM_COMPRA=:NEW.NUM_COMPRA;
        
        SELECT PVP INTO PRECIO FROM ARTICULOS 
        WHERE CODARTI=:OLD.CODARTI;
        UPDATE COMPRAS SET 
              IMPORTECOMPRAS=IMPORTECOMPRAS-PRECIO*:OLD.UNIDADES
        WHERE NUM_COMPRA=:OLD.NUM_COMPRA;
    END IF;
    
    INSERT INTO AUDITA_DET_COMPRAS 
        VALUES (TO_CHAR(SYSDATE, 'HH:MM:SS') || 'NIVEL FILA');
END;

-- PRUEBAS
INSERT INTO DET_COMPRAS VALUES(1,7,5);
DELETE FROM DET_COMPRAS WHERE NUM_COMPRA=6;


/* 10.	Cambiar el trigger para mantener actualizada la columna stock de la 
tabla artículo.
?	Si se inserta un DET_COMPRA, hay que restar las unidades de ese detalle,
y del artículo al STOCK del artículo de la tabla artículos.
?	Si se borra un detalle compra hay que sumar las unidades del artículo que 
se borra en detalle compras, al stock del artículo en la tabla ARTÍCULOS.
?	Si se actualiza un detalle compra, se restan las unidades del nuevo 
artículo al stock de la tabla artículos. Y se suman las unidades del antiguo
artículo al stock 
?	del artículo en la tabla ARTICULOS
*/

CREATE OR REPLACE TRIGGER ACTU_IMPORTECOMPRA
AFTER INSERT OR DELETE OR UPDATE ON DET_COMPRAS
FOR EACH ROW
DECLARE
  IMPOR NUMBER(9,2);
  ST NUMBER(9,2);
  NST NUMBER(9,2);
  
BEGIN
  IF INSERTING THEN
     SELECT PVP, STOCK INTO IMPOR, ST 
             FROM ARTICULOS WHERE CODARTI = :NEW.CODARTI ;
     -- COMPROBAR SUI HAY STOCK
     IF (ST - :NEW.UNIDADES)>=10 THEN
         UPDATE COMPRAS SET IMPORTECOMPRA = 
              IMPORTECOMPRA + (IMPOR * :NEW.UNIDADES )
              WHERE NUM_COMPRA = :NEW.NUM_COMPRA;
         UPDATE ARTICULOS SET STOCK = STOCK -  :NEW.UNIDADES
              WHERE CODARTI = :NEW.CODARTI;
     ELSE
         RAISE_APPLICATION_ERROR(-20000, 'ERROR NO HAY STOCK. NO SE INSERTA.');
     END IF;   
   END IF;
  
  IF UPDATING('UNIDADES') THEN
    -- SUMAMOS LAS NUEVAS
    SELECT PVP, STOCK INTO IMPOR, ST FROM ARTICULOS 
       WHERE CODARTI = :NEW.CODARTI ;
    NST := ST - :NEW.UNIDADES + :OLD.UNIDADES;
    IF (NST >=10) THEN
       -- SUMA NUEVAS
       UPDATE COMPRAS SET IMPORTECOMPRA = 
         IMPORTECOMPRA + (IMPOR * :NEW.UNIDADES )
        WHERE NUM_COMPRA = :NEW.NUM_COMPRA;
      -- RESTAMOS LAS ANTIGUAS
      SELECT   PVP INTO IMPOR 
        FROM ARTICULOS WHERE CODARTI = :OLD.CODARTI ;
      UPDATE COMPRAS SET IMPORTECOMPRA = 
           IMPORTECOMPRA - ( IMPOR *:OLD.UNIDADES)
       WHERE NUM_COMPRA = :OLD.NUM_COMPRA;
       -- ACTUALIZA ARTICULO
       UPDATE ARTICULOS SET STOCK = NST WHERE CODARTI = :NEW.CODARTI;
       
     ELSE
         RAISE_APPLICATION_ERROR(-20000, 'ERROR NO HAY STOCK. NO SE INSERTA.');
     END IF;
  END IF;
  
  IF UPDATING('CODARTI') THEN
    SELECT PVP, STOCK INTO IMPOR, ST FROM ARTICULOS 
       WHERE CODARTI = :NEW.CODARTI ;
    NST := ST - :NEW.UNIDADES;
    IF (NST >=10) THEN
       -- SUMA NUEVAS
       UPDATE COMPRAS SET IMPORTECOMPRA = 
         IMPORTECOMPRA + (IMPOR * :NEW.UNIDADES )
        WHERE NUM_COMPRA = :NEW.NUM_COMPRA;
      -- RESTAMOS LAS ANTIGUAS
      SELECT   PVP INTO IMPOR 
        FROM ARTICULOS WHERE CODARTI = :OLD.CODARTI ;
      UPDATE COMPRAS SET IMPORTECOMPRA = 
           IMPORTECOMPRA - ( IMPOR *:OLD.UNIDADES)
       WHERE NUM_COMPRA = :OLD.NUM_COMPRA;
       -- ACTUALIZA ARTICULO NUEVO
       UPDATE ARTICULOS SET STOCK = NST  WHERE CODARTI = :NEW.CODARTI;
       -- ACTUALIZA ARTICULO VIEJO
       UPDATE ARTICULOS SET STOCK = STOCK + :OLD.UNIDADES 
                    WHERE CODARTI = :OLD.CODARTI;
     ELSE
         RAISE_APPLICATION_ERROR(-20000, 'ERROR NO HAY STOCK. NO SE INSERTA.');
     END IF;
  
  END IF;
  
  IF DELETING THEN
        SELECT   PVP  INTO IMPOR  FROM ARTICULOS WHERE CODARTI = :OLD.CODARTI ; 
   UPDATE COMPRAS SET IMPORTECOMPRA = IMPORTECOMPRA - ( IMPOR *:OLD.UNIDADES)
     WHERE NUM_COMPRA = :OLD.NUM_COMPRA;    
     
     UPDATE ARTICULOS SET STOCK = STOCK +  :OLD.UNIDADES 
              WHERE CODARTI = :OLD.CODARTI;
         END IF;
END;

PRUEBA DE USO:
DELETE FROM DET_COMPRAS WHERE NUM_COMPRA=1 AND CODARTI = 1;
INSERT INTO DET_COMPRAS VALUES (1,1, 50);
UPDATE DET_COMPRAS SET UNIDADES = 101
  WHERE NUM_COMPRA=1 AND CODARTI = 1; 
DELETE FROM DET_COMPRAS WHERE NUM_COMPRA=3;



